name: Build Unity Project

on:
  workflow_dispatch:
    inputs:
      platform:
        description: 'Platform to build for'
        required: true
        type: choice
        options:
          - StandaloneWindows64
          - Android
          - iOS

jobs:
  build:
    name: Build for ${{ inputs.platform }}
    runs-on: ${{ inputs.platform == 'iOS' && 'macos-latest' || 'ubuntu-latest' }}
    
    steps:
      # Checkout repository with LFS support
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          lfs: true
      
      # Cache Unity Library folder
      - name: Cache Unity Library
        uses: actions/cache@v3
        with:
          path: Library
          key: Library-${{ inputs.platform }}-${{ hashFiles('Assets/**', 'Packages/**', 'ProjectSettings/**') }}
          restore-keys: |
            Library-${{ inputs.platform }}-
            Library-
      
      # Free up disk space for Android builds
      - name: Free disk space (Android only)
        if: inputs.platform == 'Android'
        uses: jlumbroso/free-disk-space@v1.3.1
      
      # iOS: Setup certificates and provisioning profiles
      - name: Clean iOS certificate state
        if: inputs.platform == 'iOS'
        run: |
          # Create App Store Connect API key for certificate management
          mkdir -p ~/.appstoreconnect/private_keys
          echo "${{ secrets.APPSTORE_PRIVATE_KEY }}" > ~/.appstoreconnect/private_keys/AuthKey_${{ secrets.APPSTORE_KEY_ID }}.p8
          
          # Delete any existing keychains that might have conflicting certificates
          security list-keychains | grep -o '/[^"]*\.keychain' | xargs -I {} security delete-keychain {} 2>/dev/null || true
          
          # Reset the keychain list to system defaults
          security list-keychains -s ~/Library/Keychains/login.keychain-db /Library/Keychains/System.keychain
          
          # Clear any cached Xcode signing state
          rm -rf ~/Library/Developer/Xcode/DerivedData/*/Build/Intermediates.noindex/ArchiveIntermediates/*/IntermediateBuildFilesPath/XCBuildData/*.xcbuilddata 2>/dev/null || true
          
          echo "Certificate state cleaned successfully"
      
      - name: Setup iOS certificates
        if: inputs.platform == 'iOS'
        run: |
          # Create a unique keychain to avoid conflicts
          KEYCHAIN_NAME="build-$(date +%s).keychain"
          KEYCHAIN_PASSWORD="${{ secrets.IOS_P12_PASSWORD }}"
          
          echo "Creating keychain: $KEYCHAIN_NAME"
          
          # Create and configure keychain
          security create-keychain -p "$KEYCHAIN_PASSWORD" "$KEYCHAIN_NAME"
          
          # Add to keychain search list so Xcode can find it
          security list-keychains -s "$KEYCHAIN_NAME" ~/Library/Keychains/login.keychain-db /Library/Keychains/System.keychain
          
          # Set as default and unlock
          security default-keychain -s "$KEYCHAIN_NAME"
          security unlock-keychain -p "$KEYCHAIN_PASSWORD" "$KEYCHAIN_NAME"
          security set-keychain-settings -t 3600 -u "$KEYCHAIN_NAME"
          
          echo "Keychain created and configured"
          echo "Keychain search list:"
          security list-keychains
          
          # Import certificate
          echo "Importing certificate..."
          echo "${{ secrets.IOS_P12_BASE64 }}" | base64 --decode > certificate.p12
          
          # Check if P12 file was created successfully
          if [ -f certificate.p12 ]; then
            echo "P12 file created successfully, size: $(wc -c < certificate.p12) bytes"
          else
            echo "ERROR: P12 file was not created"
            exit 1
          fi
          
          # Import the certificate with additional flags
          security import certificate.p12 -k "$KEYCHAIN_NAME" -P "${{ secrets.IOS_P12_PASSWORD }}" -T /usr/bin/codesign -T /usr/bin/productbuild -T /usr/bin/productsign || {
            echo "ERROR: Certificate import failed"
            echo "Checking keychain contents:"
            security list-keychains
            echo "Checking if keychain exists:"
            ls -la "$KEYCHAIN_NAME" 2>/dev/null || echo "Keychain file not found"
            exit 1
          }
          
          echo "Certificate imported successfully"
          
          # Set key partition list for all common tools
          security set-key-partition-list -S apple-tool:,apple:,codesign: -s -k "$KEYCHAIN_PASSWORD" "$KEYCHAIN_NAME" || {
            echo "WARNING: Failed to set key partition list, but continuing..."
          }
          
          # Make the keychain readable by all processes
          security set-keychain-settings -t 7200 -l "$KEYCHAIN_NAME"
          
          echo "Checking imported certificates:"
          security find-identity -v -p codesigning "$KEYCHAIN_NAME"
          
          # Store keychain name for later steps
          echo "KEYCHAIN_NAME=$KEYCHAIN_NAME" >> $GITHUB_ENV
          echo "KEYCHAIN_PASSWORD=$KEYCHAIN_PASSWORD" >> $GITHUB_ENV
          
          # Clean up certificate file
          rm certificate.p12
          
          echo "Certificate setup completed"
      
      - name: Download iOS provisioning profiles
        if: inputs.platform == 'iOS'
        uses: Apple-Actions/download-provisioning-profiles@v3
        with:
          bundle-id: 'com.stash.sdkdemo'
          profile-type: 'IOS_APP_STORE'
          issuer-id: ${{ secrets.APPSTORE_ISSUER_ID }}
          api-key-id: ${{ secrets.APPSTORE_KEY_ID }}
          api-private-key: ${{ secrets.APPSTORE_PRIVATE_KEY }}
      
      - name: Verify provisioning profile capabilities
        if: inputs.platform == 'iOS'
        run: |
          echo "Checking provisioning profiles..."
          for profile in ~/Library/MobileDevice/Provisioning\ Profiles/*.mobileprovision; do
            echo ""
            echo "Profile: $(basename "$profile")"
            security cms -D -i "$profile" | plutil -p - | grep -E '(Name|TeamIdentifier|UUID|Entitlements|com.apple.InAppPurchase)' || true
            echo "---"
          done
          
          # Check if any profile has In-App Purchase capability
          HAS_IAP=false
          for profile in ~/Library/MobileDevice/Provisioning\ Profiles/*.mobileprovision; do
            if security cms -D -i "$profile" | grep -q "com.apple.InAppPurchase"; then
              HAS_IAP=true
              echo "âœ… Found profile with In-App Purchase: $(basename "$profile")"
              break
            fi
          done
          
          if [ "$HAS_IAP" = "false" ]; then
            echo "âš ï¸  WARNING: No provisioning profile with In-App Purchase capability found"
            echo "The app may require In-App Purchase capability. If the build fails, ensure your App ID has In-App Purchase enabled in App Store Connect."
          fi
      
      - name: Verify iOS setup
        if: inputs.platform == 'iOS'
        run: |
          echo "Available signing identities in default keychain:"
          security find-identity -v -p codesigning
          echo ""
          
          echo "Available signing identities in our build keychain:"
          security find-identity -v -p codesigning "$KEYCHAIN_NAME"
          echo ""
          
          # Debug keychain information
          echo "Current default keychain:"
          security default-keychain
          echo ""
          echo "All keychains:"
          security list-keychains
          echo ""
          
          # Check if we have any certificates in our build keychain
          CERT_COUNT=$(security find-identity -v -p codesigning "$KEYCHAIN_NAME" | grep -c "valid identities found" | head -1)
          echo "Found $CERT_COUNT certificates in build keychain"
          
          # Check if we have a distribution certificate
          if security find-identity -v -p codesigning "$KEYCHAIN_NAME" | grep -q "Distribution"; then
            echo "âœ… Distribution certificate found"
            echo "CERT_TYPE=distribution" >> $GITHUB_ENV
          else
            echo "âš ï¸  No Distribution certificate found."
            if security find-identity -v -p codesigning "$KEYCHAIN_NAME" | grep -q "Development"; then
              echo "   Found Development certificate - this can work for TestFlight uploads."
              echo "CERT_TYPE=development" >> $GITHUB_ENV
            else
              echo "   No certificates found in build keychain."
              echo "CERT_TYPE=none" >> $GITHUB_ENV
            fi
          fi
          
          echo ""
          echo "Installed provisioning profiles:"
          ls -la ~/Library/MobileDevice/Provisioning\ Profiles/
          echo ""
          echo "Profile details:"
          for profile in ~/Library/MobileDevice/Provisioning\ Profiles/*.mobileprovision; do
            echo "Profile: $profile"
            security cms -D -i "$profile" | grep -E 'TeamIdentifier|UUID|Name|com.stash.sdkdemo' -A1
            echo "---"
          done
      
      # Build Unity project
      - name: Build Unity project
        uses: game-ci/unity-builder@v4
        env:
          UNITY_LICENSE: ${{ secrets.UNITY_LICENSE }}
          UNITY_EMAIL: ${{ secrets.UNITY_EMAIL }}
          UNITY_PASSWORD: ${{ secrets.UNITY_PASSWORD }}
        with:
          targetPlatform: ${{ inputs.platform }}
          buildName: ${{ inputs.platform == 'iOS' && 'iOS' || inputs.platform }}
          androidExportType: ${{ inputs.platform == 'Android' && 'androidAppBundle' || '' }}
          androidKeystoreName: ${{ inputs.platform == 'Android' && 'user.keystore' || '' }}
          androidKeystoreBase64: ${{ inputs.platform == 'Android' && secrets.ANDROID_KEYSTORE_BASE64 || '' }}
          androidKeystorePass: ${{ inputs.platform == 'Android' && secrets.ANDROID_KEYSTORE_PASS || '' }}
          androidKeyaliasName: ${{ inputs.platform == 'Android' && secrets.ANDROID_KEYALIAS_NAME || '' }}
          androidKeyaliasPass: ${{ inputs.platform == 'Android' && secrets.ANDROID_KEYALIAS_PASS || '' }}
      
      # iOS: Prepare Xcode project
      - name: Prepare Xcode project
        if: inputs.platform == 'iOS'
        run: |
          cd build/iOS/iOS/
          
          # Create App Store Connect API key directory
          mkdir -p ~/.appstoreconnect/private_keys
          echo "${{ secrets.APPSTORE_PRIVATE_KEY }}" > ~/.appstoreconnect/private_keys/AuthKey_${{ secrets.APPSTORE_KEY_ID }}.p8
          chmod 600 ~/.appstoreconnect/private_keys/AuthKey_${{ secrets.APPSTORE_KEY_ID }}.p8
          
          # Ensure our keychain is active and unlocked
          security default-keychain -s "$KEYCHAIN_NAME"
          security unlock-keychain -p "$KEYCHAIN_PASSWORD" "$KEYCHAIN_NAME"
          
          # Update project.pbxproj to set team ID for all targets
          echo "Setting development team ID..."
          sed -i '' "s/DevelopmentTeam = \"[^\"]*\"/DevelopmentTeam = \"${{ secrets.IOS_TEAM_ID }}\"/g" Unity-iPhone.xcodeproj/project.pbxproj
          sed -i '' "s/DevelopmentTeam = ;/DevelopmentTeam = \"${{ secrets.IOS_TEAM_ID }}\";/g" Unity-iPhone.xcodeproj/project.pbxproj
          sed -i '' "s/DEVELOPMENT_TEAM = \"[^\"]*\"/DEVELOPMENT_TEAM = \"${{ secrets.IOS_TEAM_ID }}\"/g" Unity-iPhone.xcodeproj/project.pbxproj
          sed -i '' "s/DEVELOPMENT_TEAM = ;/DEVELOPMENT_TEAM = \"${{ secrets.IOS_TEAM_ID }}\";/g" Unity-iPhone.xcodeproj/project.pbxproj
          
          # Configure code signing - use automatic signing (handles capabilities better)
          echo "Configuring code signing..."
          # Use automatic signing which should handle In-App Purchase capability automatically
          # With automatic signing, Xcode will automatically select the correct certificate
          sed -i '' 's/CODE_SIGN_STYLE = Manual/CODE_SIGN_STYLE = Automatic/g' Unity-iPhone.xcodeproj/project.pbxproj
          sed -i '' 's/CODE_SIGN_STYLE = ;/CODE_SIGN_STYLE = Automatic;/g' Unity-iPhone.xcodeproj/project.pbxproj
          
          # Remove any manual CODE_SIGN_IDENTITY settings - let automatic signing choose
          # For App Store profiles, it will automatically use "Apple Distribution"
          # Remove the entire CODE_SIGN_IDENTITY line for automatic signing
          sed -i '' '/CODE_SIGN_IDENTITY = "Apple Distribution"/d' Unity-iPhone.xcodeproj/project.pbxproj
          sed -i '' '/CODE_SIGN_IDENTITY = "Apple Development"/d' Unity-iPhone.xcodeproj/project.pbxproj
          sed -i '' '/CODE_SIGN_IDENTITY = "iPhone Developer"/d' Unity-iPhone.xcodeproj/project.pbxproj
          sed -i '' '/CODE_SIGN_IDENTITY = "iPhone Distribution"/d' Unity-iPhone.xcodeproj/project.pbxproj
          
          echo "Code signing configured for automatic signing"
          
          # Fix Unity framework issue: Set "Embedded Content Contains Swift Code" to NO
          # This prevents the "Invalid Bundle contains disallowed file 'Frameworks'" error
          # See: https://stackoverflow.com/questions/25880134/invalid-bundle-contains-disallowed-file-frameworks
          echo "Configuring Embedded Content Contains Swift Code to NO (Unity fix)..."
          # Set ALWAYS_EMBED_SWIFT_STANDARD_LIBRARIES to NO for all targets
          # This fixes the "Invalid Bundle contains disallowed file 'Frameworks'" error
          sed -i '' 's/ALWAYS_EMBED_SWIFT_STANDARD_LIBRARIES = YES/ALWAYS_EMBED_SWIFT_STANDARD_LIBRARIES = NO/g' Unity-iPhone.xcodeproj/project.pbxproj
          sed -i '' 's/ALWAYS_EMBED_SWIFT_STANDARD_LIBRARIES = "$(inherited)"/ALWAYS_EMBED_SWIFT_STANDARD_LIBRARIES = NO/g' Unity-iPhone.xcodeproj/project.pbxproj
          # Also set EMBEDDED_CONTENT_CONTAINS_SWIFT to NO if present
          sed -i '' 's/EMBEDDED_CONTENT_CONTAINS_SWIFT = YES/EMBEDDED_CONTENT_CONTAINS_SWIFT = NO/g' Unity-iPhone.xcodeproj/project.pbxproj
          echo "Embedded Content Contains Swift Code configured to NO"
          
          # Fix UnityFramework bundle identifier collision
          # UnityFramework must have a unique bundle ID, not the same as the main app
          echo "Setting unique bundle identifier for UnityFramework..."
          MAIN_BUNDLE_ID="com.stash.sdkdemo"
          UNITY_FRAMEWORK_BUNDLE_ID="${MAIN_BUNDLE_ID}.UnityFramework"
          
          # Write improved Python script that finds UnityFramework target build configurations
          printf 'import re\nimport sys\nproject_file = sys.argv[1]\nmain_bundle_id = sys.argv[2]\nframework_bundle_id = sys.argv[3]\nwith open(project_file, "r") as f:\n    lines = f.readlines()\ncontent = "".join(lines)\n\n# Strategy: Find build configuration sections that belong to UnityFramework target\n# Xcode project structure: build configurations are associated with targets via PBXNativeTarget sections\n\n# Step 1: Find all PRODUCT_BUNDLE_IDENTIFIER entries\npattern = r\'PRODUCT_BUNDLE_IDENTIFIER = "\' + re.escape(main_bundle_id) + r\'";\'\nmatches = list(re.finditer(pattern, content))\nprint(f"Found {len(matches)} instances of bundle ID {main_bundle_id}")\n\n# Step 2: Find the UnityFramework target UUID\n# Look for PBXNativeTarget sections that mention UnityFramework\nunity_framework_target_uuids = set()\nfor i, line in enumerate(lines):\n    if "UnityFramework" in line and "PBXNativeTarget" in "".join(lines[max(0, i-5):i+5]):\n        # Extract UUID from the line (format: UUID /* UnityFramework */ = {)\n        uuid_match = re.search(r\'([A-F0-9]{24})\', line)\n        if uuid_match:\n            unity_framework_target_uuids.add(uuid_match.group(1))\n            print(f"Found UnityFramework target UUID: {uuid_match.group(1)}")\n\n# Step 3: Find build configuration list UUIDs for UnityFramework target\nunity_framework_build_config_list_uuids = set()\nfor uuid in unity_framework_target_uuids:\n    # Find the buildConfigurationList reference for this target\n    pattern = rf\'{re.escape(uuid)}.*buildConfigurationList = ([A-F0-9]{{24}}) .*/\* Build configuration list\'\n    match = re.search(pattern, content)\n    if match:\n        unity_framework_build_config_list_uuids.add(match.group(1))\n        print(f"Found UnityFramework build config list UUID: {match.group(1)}")\n\n# Step 4: Find all build configuration UUIDs in the UnityFramework build config list\nunity_framework_build_config_uuids = set()\nfor config_list_uuid in unity_framework_build_config_list_uuids:\n    # Find buildConfigurations array for this list\n    pattern = rf\'{re.escape(config_list_uuid)}.*buildConfigurations = \(\s*((?:[A-F0-9]{{24}}\s*/\*[^*]+\*/\s*=\s*[A-F0-9]{{24}}\s*;?\s*)+)\'\n    match = re.search(pattern, content, re.DOTALL)\n    if match:\n        # Extract all UUIDs from the buildConfigurations array\n        uuids = re.findall(r\'([A-F0-9]{{24}})\', match.group(1))\n        unity_framework_build_config_uuids.update(uuids)\n        print(f"Found {len(uuids)} build configuration UUIDs for UnityFramework")\n\n# Step 5: Find buildSettings sections for UnityFramework build configurations\nupdated = False\nfor config_uuid in unity_framework_build_config_uuids:\n    # Find the buildSettings section for this configuration\n    # Format: config_uuid /* Debug or Release */ = { isa = XCBuildConfiguration; buildSettings = { ... PRODUCT_BUNDLE_IDENTIFIER ... }; };\n    pattern = rf\'({re.escape(config_uuid)}[^{{]*{{[^}}]*buildSettings = {{[^}}]*)(PRODUCT_BUNDLE_IDENTIFIER = "{re.escape(main_bundle_id)}";)([^}}]*}};)\'\n    match = re.search(pattern, content, re.DOTALL)\n    if match:\n        replacement = match.group(1) + f\'PRODUCT_BUNDLE_IDENTIFIER = "{framework_bundle_id}";\' + match.group(3)\n        content = content[:match.start()] + replacement + content[match.end():]\n        updated = True\n        print(f"Updated build configuration {config_uuid}")\n\n# Fallback: If we could not find target UUIDs, use a simpler approach\n# Look for PRODUCT_BUNDLE_IDENTIFIER that appears in sections containing "UnityFramework"\nif not updated and matches:\n    print("Fallback: Using context-based approach...")\n    for match in reversed(matches):\n        start = match.start()\n        # Look back 2000 chars for context\n        context_start = max(0, start - 2000)\n        context = content[context_start:start]\n        \n        # Check if this appears to be in a UnityFramework-related section\n        # Look for "UnityFramework" or framework-related keywords nearby\n        if "UnityFramework" in context or "FMWK" in context:\n            # Make sure it is not in the main app target section\n            # Main app is usually "Unity-iPhone" or the scheme name\n            main_app_keywords = ["Unity-iPhone", "PRODUCT_NAME = Unity-iPhone", "PRODUCT_NAME = StashDemo"]\n            is_main_app = any(keyword in context for keyword in main_app_keywords)\n            \n            if not is_main_app:\n                content = content[:match.start()] + f\'PRODUCT_BUNDLE_IDENTIFIER = "{framework_bundle_id}";\' + content[match.end():]\n                updated = True\n                print(f"Updated bundle ID at position {start} (fallback method)")\n\nif updated:\n    with open(project_file, "w") as f:\n        f.write(content)\n    print(f"Successfully updated UnityFramework bundle ID to: {framework_bundle_id}")\nelse:\n    print("WARNING: Could not update UnityFramework bundle ID in project file")\n    print("This will be fixed post-archive if needed")\n' > /tmp/fix_unity_bundle_id.py
          
          # Run the Python script
          python3 /tmp/fix_unity_bundle_id.py Unity-iPhone.xcodeproj/project.pbxproj "$MAIN_BUNDLE_ID" "$UNITY_FRAMEWORK_BUNDLE_ID"
          rm -f /tmp/fix_unity_bundle_id.py
          
          echo "UnityFramework bundle ID configuration complete"
          
          # Force device-only builds by excluding simulator architectures
          echo "Configuring for device-only build..."
          # Set ONLY_ACTIVE_ARCH to NO for Release builds
          sed -i '' 's/ONLY_ACTIVE_ARCH = YES/ONLY_ACTIVE_ARCH = NO/g' Unity-iPhone.xcodeproj/project.pbxproj
          
          echo "Build configuration updated for device-only build"
          
          # Get the provisioning profile UUID for manual signing
          # Prefer a profile with In-App Purchase capability
          PROFILE_PATH=""
          PROFILE_UUID=""
          
          # First, try to find a profile with In-App Purchase
          for profile in ~/Library/MobileDevice/Provisioning\ Profiles/*.mobileprovision; do
            if security cms -D -i "$profile" | grep -q "com.apple.InAppPurchase"; then
              PROFILE_PATH="$profile"
              PROFILE_UUID=$(basename "$profile" .mobileprovision)
              echo "âœ… Found profile with In-App Purchase: $PROFILE_UUID"
              break
            fi
          done
          
          # If no IAP profile found, use the first available profile
          if [ -z "$PROFILE_PATH" ]; then
            PROFILE_PATH=$(ls ~/Library/MobileDevice/Provisioning\ Profiles/*.mobileprovision | head -1)
            PROFILE_UUID=$(basename "$PROFILE_PATH" .mobileprovision)
            echo "âš ï¸  Using profile without In-App Purchase: $PROFILE_UUID"
            echo "âš ï¸  WARNING: This may cause build failures if the app requires In-App Purchase"
          fi
          
          echo "PROFILE_UUID=$PROFILE_UUID" >> $GITHUB_ENV
          echo "Using provisioning profile: $PROFILE_UUID from $PROFILE_PATH"
          
          # Extract the actual UUID from the profile (not just filename)
          ACTUAL_UUID=$(security cms -D -i "$PROFILE_PATH" | plutil -extract UUID raw - 2>/dev/null || echo "$PROFILE_UUID")
          echo "ACTUAL_PROFILE_UUID=$ACTUAL_UUID" >> $GITHUB_ENV
          echo "Actual profile UUID: $ACTUAL_UUID"
      
      # iOS: Verify build configuration
      - name: Verify build configuration
        if: inputs.platform == 'iOS'
        run: |
          cd build/iOS/iOS/
          
          echo "Available SDKs:"
          xcodebuild -showsdks | grep -i ios
          
          echo ""
          echo "Available destinations:"
          xcodebuild -project Unity-iPhone.xcodeproj -scheme Unity-iPhone -showdestinations | grep -i ios
          
          echo ""
          echo "Verifying we're building for device (iphoneos), not simulator..."
          SDK_VERSION=$(xcodebuild -version -sdk iphoneos Path 2>/dev/null | head -1)
          if [ -z "$SDK_VERSION" ]; then
            echo "ERROR: iphoneos SDK not found!"
            exit 1
          fi
          echo "âœ… Using device SDK: $SDK_VERSION"
      
      # iOS: Clean Xcode project
      - name: Clean Xcode project
        if: inputs.platform == 'iOS'
        run: |
          cd build/iOS/iOS/
          xcodebuild clean \
            -project Unity-iPhone.xcodeproj \
            -scheme Unity-iPhone \
            -configuration Release \
            -sdk iphoneos \
            -destination 'generic/platform=iOS'
      
      # iOS: Build archive for device
      - name: Build iOS archive
        if: inputs.platform == 'iOS'
        env:
          APP_STORE_CONNECT_API_KEY_ID: ${{ secrets.APPSTORE_KEY_ID }}
          APP_STORE_CONNECT_API_KEY_ISSUER_ID: ${{ secrets.APPSTORE_ISSUER_ID }}
          APP_STORE_CONNECT_API_KEY_KEY: ${{ secrets.APPSTORE_PRIVATE_KEY }}
          APP_STORE_CONNECT_API_KEY_IS_KEY_CONTENT_BASE64: false
        run: |
          cd build/iOS/iOS/
          
          # Ensure keychain is unlocked and in search path
          security unlock-keychain -p "$KEYCHAIN_PASSWORD" "$KEYCHAIN_NAME"
          security list-keychains -s "$KEYCHAIN_NAME" ~/Library/Keychains/login.keychain-db /Library/Keychains/System.keychain
          
          # Build archive for device (not simulator)
          # Use generic iOS device destination to avoid simulator
          xcodebuild archive \
            -project Unity-iPhone.xcodeproj \
            -scheme Unity-iPhone \
            -configuration Release \
            -sdk iphoneos \
            -destination 'generic/platform=iOS' \
            -archivePath Unity-iPhone.xcarchive \
            -allowProvisioningUpdates \
            -allowProvisioningDeviceRegistration \
            -authenticationKeyPath ~/.appstoreconnect/private_keys/AuthKey_${{ secrets.APPSTORE_KEY_ID }}.p8 \
            -authenticationKeyID ${{ secrets.APPSTORE_KEY_ID }} \
            -authenticationKeyIssuerID ${{ secrets.APPSTORE_ISSUER_ID }} \
            DEVELOPMENT_TEAM="${{ secrets.IOS_TEAM_ID }}" \
            PRODUCT_BUNDLE_IDENTIFIER="com.stash.sdkdemo" \
            CODE_SIGN_STYLE="Automatic" \
            CODE_SIGNING_ALLOWED="YES" \
            CODE_SIGNING_REQUIRED="YES" \
            ALWAYS_EMBED_SWIFT_STANDARD_LIBRARIES=NO \
            OTHER_CODE_SIGN_FLAGS="--keychain $KEYCHAIN_NAME" \
            ONLY_ACTIVE_ARCH=NO \
            EXCLUDED_ARCHS[sdk=iphonesimulator*]="arm64"
          
          echo "Archive created successfully"
          ls -la Unity-iPhone.xcarchive/
          
          # Verify bundle identifiers are correct
          echo ""
          echo "Verifying bundle identifiers..."
          APP_BUNDLE=$(find Unity-iPhone.xcarchive -name "*.app" -type d | head -1)
          if [ -n "$APP_BUNDLE" ]; then
            # Check main app bundle identifier
            MAIN_BUNDLE_ID=$(plutil -extract CFBundleIdentifier raw "$APP_BUNDLE/Info.plist" 2>/dev/null || echo "")
            echo "Main app bundle ID: $MAIN_BUNDLE_ID"
            
            # Check UnityFramework bundle identifier
            UNITY_FRAMEWORK_PLIST="$APP_BUNDLE/Frameworks/UnityFramework.framework/Info.plist"
            if [ -f "$UNITY_FRAMEWORK_PLIST" ]; then
              UNITY_FRAMEWORK_BUNDLE_ID=$(plutil -extract CFBundleIdentifier raw "$UNITY_FRAMEWORK_PLIST" 2>/dev/null || echo "")
              if [ -n "$UNITY_FRAMEWORK_BUNDLE_ID" ]; then
                echo "UnityFramework bundle ID: $UNITY_FRAMEWORK_BUNDLE_ID"
                if [ "$UNITY_FRAMEWORK_BUNDLE_ID" = "$MAIN_BUNDLE_ID" ]; then
                  echo "âš ï¸  WARNING: UnityFramework has same bundle ID as main app!"
                elif [ "$UNITY_FRAMEWORK_BUNDLE_ID" = "${MAIN_BUNDLE_ID}.UnityFramework" ]; then
                  echo "âœ… UnityFramework has unique bundle ID"
                else
                  echo "â„¹ï¸  UnityFramework bundle ID is different: $UNITY_FRAMEWORK_BUNDLE_ID"
                fi
              else
                echo "âš ï¸  WARNING: UnityFramework has no bundle ID (this will cause validation errors)"
              fi
            fi
            
            # Check for nested Frameworks folder (the Unity issue)
            if [ -d "$APP_BUNDLE/Frameworks/UnityFramework.framework/Frameworks" ]; then
              echo "âš ï¸  WARNING: Found nested Frameworks folder in UnityFramework.framework"
              echo "   This should be fixed by ALWAYS_EMBED_SWIFT_STANDARD_LIBRARIES=NO"
            else
              echo "âœ… No nested Frameworks folder found"
            fi
          fi
          
          # Verify archive is built for device, not simulator
          echo ""
          echo "Verifying archive architecture..."
          ARCHIVE_BINARY=$(find Unity-iPhone.xcarchive -name "UnityFramework" -type f | head -1)
          if [ -n "$ARCHIVE_BINARY" ]; then
            echo "Checking binary architectures:"
            file "$ARCHIVE_BINARY"
            lipo -info "$ARCHIVE_BINARY" || echo "lipo info:"
            echo ""
            echo "Checking for simulator architectures (should be empty):"
            lipo -info "$ARCHIVE_BINARY" 2>&1 | grep -i simulator && echo "âš ï¸  WARNING: Simulator architectures found!" || echo "âœ… No simulator architectures found"
          fi
      
      # iOS: Fix UnityFramework bundle identifier in archive (post-archive fix)
      - name: Fix UnityFramework bundle identifier in archive
        if: inputs.platform == 'iOS'
        run: |
          cd build/iOS/iOS/
          
          echo "Fixing UnityFramework bundle identifier in archive..."
          
          # Find the app bundle in the archive
          APP_BUNDLE=$(find Unity-iPhone.xcarchive -name "*.app" -type d | head -1)
          if [ -z "$APP_BUNDLE" ]; then
            echo "ERROR: Could not find app bundle in archive"
            exit 1
          fi
          
          MAIN_BUNDLE_ID="com.stash.sdkdemo"
          UNITY_FRAMEWORK_BUNDLE_ID="${MAIN_BUNDLE_ID}.UnityFramework"
          UNITY_FRAMEWORK_PLIST="$APP_BUNDLE/Frameworks/UnityFramework.framework/Info.plist"
          
          if [ ! -f "$UNITY_FRAMEWORK_PLIST" ]; then
            echo "UnityFramework.framework/Info.plist not found, skipping fix"
            exit 0
          fi
          
          # Check current bundle ID
          CURRENT_BUNDLE_ID=$(plutil -extract CFBundleIdentifier raw "$UNITY_FRAMEWORK_PLIST" 2>/dev/null || echo "")
          echo "UnityFramework current bundle ID: $CURRENT_BUNDLE_ID"
          echo "Target bundle ID: $UNITY_FRAMEWORK_BUNDLE_ID"
          
          if [ "$CURRENT_BUNDLE_ID" = "$MAIN_BUNDLE_ID" ]; then
            echo "âš ï¸  UnityFramework still has main app bundle ID. Fixing in archive..."
            
            # Update the bundle ID in Info.plist
            plutil -replace CFBundleIdentifier -string "$UNITY_FRAMEWORK_BUNDLE_ID" "$UNITY_FRAMEWORK_PLIST"
            echo "âœ… Updated Info.plist bundle ID"
            
            # Remove code signatures so export will re-sign with correct bundle IDs
            # Modifying Info.plist invalidates signatures, so we need to remove them
            echo "Removing code signatures (export will re-sign automatically)..."
            
            # Remove _CodeSignature folders to invalidate signatures
            # The export process will detect unsigned frameworks and re-sign them
            if [ -d "$APP_BUNDLE/Frameworks/UnityFramework.framework/_CodeSignature" ]; then
              rm -rf "$APP_BUNDLE/Frameworks/UnityFramework.framework/_CodeSignature"
              echo "âœ… Removed UnityFramework.framework code signature"
            fi
            
            if [ -d "$APP_BUNDLE/_CodeSignature" ]; then
              rm -rf "$APP_BUNDLE/_CodeSignature"
              echo "âœ… Removed main app code signature"
            fi
            
            echo "âœ… Signatures removed - export process will re-sign with correct bundle IDs"
            
            # Verify the bundle ID was updated
            VERIFY_BUNDLE_ID=$(plutil -extract CFBundleIdentifier raw "$UNITY_FRAMEWORK_PLIST" 2>/dev/null || echo "")
            if [ "$VERIFY_BUNDLE_ID" = "$UNITY_FRAMEWORK_BUNDLE_ID" ]; then
              echo "âœ… Verified: UnityFramework bundle ID is now: $VERIFY_BUNDLE_ID"
              echo "â„¹ï¸  Code signatures removed - export process will re-sign with correct bundle IDs"
            else
              echo "âš ï¸  WARNING: Bundle ID update may have failed. Current: $VERIFY_BUNDLE_ID"
            fi
          elif [ "$CURRENT_BUNDLE_ID" = "$UNITY_FRAMEWORK_BUNDLE_ID" ]; then
            echo "âœ… UnityFramework already has correct bundle ID: $UNITY_FRAMEWORK_BUNDLE_ID"
          else
            echo "â„¹ï¸  UnityFramework bundle ID is: $CURRENT_BUNDLE_ID (different from expected)"
          fi
      
      # iOS: Create export options
      - name: Create export options plist
        if: inputs.platform == 'iOS'
        run: |
          cd build/iOS/iOS/
          
          cat > exportOptions.plist << EOF
          <?xml version="1.0" encoding="UTF-8"?>
          <!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
          <plist version="1.0">
          <dict>
              <key>method</key>
              <string>app-store</string>
              <key>teamID</key>
              <string>${{ secrets.IOS_TEAM_ID }}</string>
              <key>signingStyle</key>
              <string>automatic</string>
              <key>uploadBitcode</key>
              <false/>
              <key>uploadSymbols</key>
              <true/>
              <key>generateAppStoreInformation</key>
              <false/>
          </dict>
          </plist>
          EOF
          
          echo "Export options created:"
          cat exportOptions.plist
      
      # iOS: Export IPA
      - name: Export IPA
        if: inputs.platform == 'iOS'
        env:
          APP_STORE_CONNECT_API_KEY_ID: ${{ secrets.APPSTORE_KEY_ID }}
          APP_STORE_CONNECT_API_KEY_ISSUER_ID: ${{ secrets.APPSTORE_ISSUER_ID }}
          APP_STORE_CONNECT_API_KEY_KEY: ${{ secrets.APPSTORE_PRIVATE_KEY }}
          APP_STORE_CONNECT_API_KEY_IS_KEY_CONTENT_BASE64: false
        run: |
          cd build/iOS/iOS/
          
          # Ensure keychain is unlocked
          security unlock-keychain -p "$KEYCHAIN_PASSWORD" "$KEYCHAIN_NAME"
          
          # Export IPA
          xcodebuild -exportArchive \
            -archivePath Unity-iPhone.xcarchive \
            -exportOptionsPlist exportOptions.plist \
            -exportPath export \
            -allowProvisioningUpdates \
            -authenticationKeyPath ~/.appstoreconnect/private_keys/AuthKey_${{ secrets.APPSTORE_KEY_ID }}.p8 \
            -authenticationKeyID ${{ secrets.APPSTORE_KEY_ID }} \
            -authenticationKeyIssuerID ${{ secrets.APPSTORE_ISSUER_ID }}
          
          echo "IPA export completed"
          ls -la export/
      
      # iOS: Diagnose bundle identifier collisions
      - name: Diagnose bundle identifier collisions
        if: inputs.platform == 'iOS'
        run: |
          cd build/iOS/iOS/export/
          IPA_PATH="StashDemo.ipa"
          
          if [ ! -f "$IPA_PATH" ]; then
            echo "ERROR: IPA file not found!"
            exit 1
          fi
          
          echo "=========================================="
          echo "DIAGNOSING BUNDLE IDENTIFIER COLLISIONS"
          echo "=========================================="
          echo ""
          
          # Extract IPA to temporary directory
          TEMP_DIR=$(mktemp -d)
          echo "Extracting IPA to: $TEMP_DIR"
          unzip -q "$IPA_PATH" -d "$TEMP_DIR/extracted"
          
          # Find the app bundle
          APP_BUNDLE=$(find "$TEMP_DIR/extracted" -name "*.app" -type d | head -1)
          if [ -z "$APP_BUNDLE" ]; then
            echo "ERROR: Could not find app bundle in IPA"
            exit 1
          fi
          
          echo "App bundle found: $APP_BUNDLE"
          echo ""
          
          # Get main app bundle ID
          MAIN_BUNDLE_ID=$(plutil -extract CFBundleIdentifier raw "$APP_BUNDLE/Info.plist" 2>/dev/null || echo "")
          echo "ðŸ“± Main App Bundle ID: $MAIN_BUNDLE_ID"
          echo ""
          
          # Find all Info.plist files in the app bundle
          echo "Searching for all Info.plist files..."
          echo "----------------------------------------"
          COLLISIONS_FOUND=0
          
          find "$APP_BUNDLE" -name "Info.plist" -type f | while read plist; do
            RELATIVE_PATH="${plist#$APP_BUNDLE/}"
            BUNDLE_ID=$(plutil -extract CFBundleIdentifier raw "$plist" 2>/dev/null || echo "")
            
            if [ -n "$BUNDLE_ID" ]; then
              echo ""
              echo "ðŸ“ Location: $RELATIVE_PATH"
              echo "   Bundle ID: $BUNDLE_ID"
              
              if [ "$BUNDLE_ID" = "$MAIN_BUNDLE_ID" ]; then
                echo "   âš ï¸  COLLISION DETECTED - Same as main app!"
                COLLISIONS_FOUND=1
                
                # Show more details about this file
                echo "   Details:"
                plutil -p "$plist" | grep -E "(CFBundleName|CFBundleExecutable|CFBundlePackageType)" | head -3 | sed 's/^/      /'
              else
                echo "   âœ“ Unique bundle ID"
              fi
            else
              echo ""
              echo "ðŸ“ Location: $RELATIVE_PATH"
              echo "   (No CFBundleIdentifier found)"
            fi
          done
          
          echo ""
          echo "----------------------------------------"
          echo "Summary of bundle structure:"
          echo ""
          echo "Frameworks:"
          find "$APP_BUNDLE/Frameworks" -name "*.framework" -type d 2>/dev/null | while read fw; do
            echo "  - $(basename "$fw")"
          done
          
          echo ""
          echo "Extensions:"
          find "$APP_BUNDLE" -name "*.appex" -type d 2>/dev/null | while read ext; do
            echo "  - $(basename "$ext")"
          done
          
          echo ""
          echo "PlugIns:"
          find "$APP_BUNDLE/PlugIns" -name "*.appex" -type d 2>/dev/null | while read plugin; do
            echo "  - $(basename "$plugin")"
          done
          
          echo ""
          echo "=========================================="
          echo "Diagnostic complete. Check output above for collisions."
          echo "=========================================="
          
          # Cleanup
          rm -rf "$TEMP_DIR"
      
      # iOS: Verify IPA
      - name: Verify IPA
        if: inputs.platform == 'iOS'
        run: |
          echo "Contents of build/iOS/iOS/export:"
          ls -la build/iOS/iOS/export/
          echo ""
          echo "Looking for IPA files:"
          find build/iOS/iOS -name "*.ipa" -type f
          
          # Verify IPA exists
          if [ ! -f "build/iOS/iOS/export/StashDemo.ipa" ]; then
            echo "ERROR: IPA file not found!"
            exit 1
          fi
          
          echo "âœ… IPA file found: build/iOS/iOS/export/StashDemo.ipa"
          du -h build/iOS/iOS/export/StashDemo.ipa
      
      # iOS: Upload to TestFlight using Apple's recommended action
      - name: Upload to TestFlight
        if: inputs.platform == 'iOS'
        uses: apple-actions/upload-testflight-build@v1
        with:
          app-path: 'build/iOS/iOS/export/StashDemo.ipa'
          issuer-id: ${{ secrets.APPSTORE_ISSUER_ID }}
          api-key-id: ${{ secrets.APPSTORE_KEY_ID }}
          api-private-key: ${{ secrets.APPSTORE_PRIVATE_KEY }}
      
      # Upload build artifacts
      - name: Upload build artifacts
        uses: actions/upload-artifact@v4
        with:
          name: Build-${{ inputs.platform }}
          path: build/${{ inputs.platform }}
          retention-days: 7
