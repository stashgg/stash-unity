name: Build Unity Project

on:
  workflow_dispatch:
    inputs:
      platform:
        description: 'Platform to build for'
        required: true
        type: choice
        options:
          - StandaloneWindows64
          - Android
          - iOS

jobs:
  build:
    name: Build for ${{ inputs.platform }}
    runs-on: ${{ inputs.platform == 'iOS' && 'macos-latest' || 'ubuntu-latest' }}
    
    steps:
      # Checkout repository with LFS support
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          fetch-tags: true
          lfs: true
      
      # Cache Unity Library folder
      - name: Cache Unity Library
        uses: actions/cache@v3
        with:
          path: Library
          key: Library-${{ inputs.platform }}-${{ hashFiles('Assets/**', 'Packages/**', 'ProjectSettings/**') }}
          restore-keys: |
            Library-${{ inputs.platform }}-
            Library-
      
      # Free up disk space for Android builds
      - name: Free disk space (Android only)
        if: inputs.platform == 'Android'
        uses: jlumbroso/free-disk-space@v1.3.1
      
      # iOS: Setup certificates and provisioning profiles
      - name: Clean iOS certificate state
        if: inputs.platform == 'iOS'
        run: |
          # Create App Store Connect API key for certificate management
          mkdir -p ~/.appstoreconnect/private_keys
          echo "${{ secrets.APPSTORE_PRIVATE_KEY }}" > ~/.appstoreconnect/private_keys/AuthKey_${{ secrets.APPSTORE_KEY_ID }}.p8
          
          # Delete any existing keychains that might have conflicting certificates
          security list-keychains | grep -o '/[^"]*\.keychain' | xargs -I {} security delete-keychain {} 2>/dev/null || true
          
          # Reset the keychain list to system defaults
          security list-keychains -s ~/Library/Keychains/login.keychain-db /Library/Keychains/System.keychain
          
          # Clear any cached Xcode signing state
          rm -rf ~/Library/Developer/Xcode/DerivedData/*/Build/Intermediates.noindex/ArchiveIntermediates/*/IntermediateBuildFilesPath/XCBuildData/*.xcbuilddata 2>/dev/null || true
          
          echo "Certificate state cleaned successfully"
      
      - name: Setup iOS certificates
        if: inputs.platform == 'iOS'
        run: |
          # Create a unique keychain to avoid conflicts
          KEYCHAIN_NAME="build-$(date +%s).keychain"
          KEYCHAIN_PASSWORD="${{ secrets.IOS_P12_PASSWORD }}"
          
          echo "Creating keychain: $KEYCHAIN_NAME"
          
          # Create and configure keychain
          security create-keychain -p "$KEYCHAIN_PASSWORD" "$KEYCHAIN_NAME"
          
          # Add to keychain search list so Xcode can find it
          security list-keychains -s "$KEYCHAIN_NAME" ~/Library/Keychains/login.keychain-db /Library/Keychains/System.keychain
          
          # Set as default and unlock
          security default-keychain -s "$KEYCHAIN_NAME"
          security unlock-keychain -p "$KEYCHAIN_PASSWORD" "$KEYCHAIN_NAME"
          security set-keychain-settings -t 3600 -u "$KEYCHAIN_NAME"
          
          echo "Keychain created and configured"
          echo "Keychain search list:"
          security list-keychains
          
          # Import certificate
          echo "Importing certificate..."
          echo "${{ secrets.IOS_P12_BASE64 }}" | base64 --decode > certificate.p12
          
          # Check if P12 file was created successfully
          if [ -f certificate.p12 ]; then
            echo "P12 file created successfully, size: $(wc -c < certificate.p12) bytes"
          else
            echo "ERROR: P12 file was not created"
            exit 1
          fi
          
          # Import the certificate with additional flags
          security import certificate.p12 -k "$KEYCHAIN_NAME" -P "${{ secrets.IOS_P12_PASSWORD }}" -T /usr/bin/codesign -T /usr/bin/productbuild -T /usr/bin/productsign || {
            echo "ERROR: Certificate import failed"
            echo "Checking keychain contents:"
            security list-keychains
            echo "Checking if keychain exists:"
            ls -la "$KEYCHAIN_NAME" 2>/dev/null || echo "Keychain file not found"
            exit 1
          }
          
          echo "Certificate imported successfully"
          
          # Set key partition list for all common tools
          security set-key-partition-list -S apple-tool:,apple:,codesign: -s -k "$KEYCHAIN_PASSWORD" "$KEYCHAIN_NAME" || {
            echo "WARNING: Failed to set key partition list, but continuing..."
          }
          
          # Make the keychain readable by all processes
          security set-keychain-settings -t 7200 -l "$KEYCHAIN_NAME"
          
          echo "Checking imported certificates:"
          security find-identity -v -p codesigning "$KEYCHAIN_NAME"
          
          # Store keychain name for later steps
          echo "KEYCHAIN_NAME=$KEYCHAIN_NAME" >> $GITHUB_ENV
          echo "KEYCHAIN_PASSWORD=$KEYCHAIN_PASSWORD" >> $GITHUB_ENV
          
          # Clean up certificate file
          rm certificate.p12
          
          echo "Certificate setup completed"
      
      - name: Download iOS provisioning profiles
        if: inputs.platform == 'iOS'
        uses: Apple-Actions/download-provisioning-profiles@v4
        with:
          bundle-id: 'com.stash.sdkdemo'
          profile-type: 'IOS_APP_STORE'
          issuer-id: ${{ secrets.APPSTORE_ISSUER_ID }}
          api-key-id: ${{ secrets.APPSTORE_KEY_ID }}
          api-private-key: ${{ secrets.APPSTORE_PRIVATE_KEY }}
      
      - name: Verify provisioning profile capabilities
        if: inputs.platform == 'iOS'
        run: |
          echo "Checking provisioning profiles..."
          for profile in ~/Library/MobileDevice/Provisioning\ Profiles/*.mobileprovision; do
            echo ""
            echo "Profile: $(basename "$profile")"
            security cms -D -i "$profile" | plutil -p - | grep -E '(Name|TeamIdentifier|UUID|Entitlements|com.apple.InAppPurchase)' || true
            echo "---"
          done
          
          # Check if any profile has In-App Purchase capability
          HAS_IAP=false
          for profile in ~/Library/MobileDevice/Provisioning\ Profiles/*.mobileprovision; do
            if security cms -D -i "$profile" | grep -q "com.apple.InAppPurchase"; then
              HAS_IAP=true
              echo "âœ… Found profile with In-App Purchase: $(basename "$profile")"
              break
            fi
          done
          
          if [ "$HAS_IAP" = "false" ]; then
            echo "âš ï¸  WARNING: No provisioning profile with In-App Purchase capability found"
            echo "The app may require In-App Purchase capability. If the build fails, ensure your App ID has In-App Purchase enabled in App Store Connect."
          fi
      
      - name: Verify iOS setup
        if: inputs.platform == 'iOS'
        run: |
          echo "Available signing identities in default keychain:"
          security find-identity -v -p codesigning
          echo ""
          
          echo "Available signing identities in our build keychain:"
          security find-identity -v -p codesigning "$KEYCHAIN_NAME"
          echo ""
          
          # Debug keychain information
          echo "Current default keychain:"
          security default-keychain
          echo ""
          echo "All keychains:"
          security list-keychains
          echo ""
          
          # Check if we have any certificates in our build keychain
          CERT_COUNT=$(security find-identity -v -p codesigning "$KEYCHAIN_NAME" | grep -c "valid identities found" | head -1)
          echo "Found $CERT_COUNT certificates in build keychain"
          
          # Check if we have a distribution certificate
          if security find-identity -v -p codesigning "$KEYCHAIN_NAME" | grep -q "Distribution"; then
            echo "âœ… Distribution certificate found"
            echo "CERT_TYPE=distribution" >> $GITHUB_ENV
          else
            echo "âš ï¸  No Distribution certificate found."
            if security find-identity -v -p codesigning "$KEYCHAIN_NAME" | grep -q "Development"; then
              echo "   Found Development certificate - this can work for TestFlight uploads."
              echo "CERT_TYPE=development" >> $GITHUB_ENV
            else
              echo "   No certificates found in build keychain."
              echo "CERT_TYPE=none" >> $GITHUB_ENV
            fi
          fi
          
          echo ""
          echo "Installed provisioning profiles:"
          ls -la ~/Library/MobileDevice/Provisioning\ Profiles/
          echo ""
          echo "Profile details:"
          for profile in ~/Library/MobileDevice/Provisioning\ Profiles/*.mobileprovision; do
            echo "Profile: $profile"
            security cms -D -i "$profile" | grep -E 'TeamIdentifier|UUID|Name|com.stash.sdkdemo' -A1
            echo "---"
          done
      
      # Build Unity project
      - name: Build Unity project
        uses: game-ci/unity-builder@v4
        env:
          UNITY_LICENSE: ${{ secrets.UNITY_LICENSE }}
          UNITY_EMAIL: ${{ secrets.UNITY_EMAIL }}
          UNITY_PASSWORD: ${{ secrets.UNITY_PASSWORD }}
        with:
          targetPlatform: ${{ inputs.platform }}
          buildName: ${{ inputs.platform == 'iOS' && 'iOS' || inputs.platform }}
          androidExportType: ${{ inputs.platform == 'Android' && 'androidAppBundle' || '' }}
          androidKeystoreName: ${{ inputs.platform == 'Android' && 'user.keystore' || '' }}
          androidKeystoreBase64: ${{ inputs.platform == 'Android' && secrets.ANDROID_KEYSTORE_BASE64 || '' }}
          androidKeystorePass: ${{ inputs.platform == 'Android' && secrets.ANDROID_KEYSTORE_PASS || '' }}
          androidKeyaliasName: ${{ inputs.platform == 'Android' && secrets.ANDROID_KEYALIAS_NAME || '' }}
          androidKeyaliasPass: ${{ inputs.platform == 'Android' && secrets.ANDROID_KEYALIAS_PASS || '' }}
      
      # iOS: Prepare Xcode project
      - name: Prepare Xcode project
        if: inputs.platform == 'iOS'
        run: |
          cd build/iOS/iOS/
          
          # Create App Store Connect API key directory
          mkdir -p ~/.appstoreconnect/private_keys
          echo "${{ secrets.APPSTORE_PRIVATE_KEY }}" > ~/.appstoreconnect/private_keys/AuthKey_${{ secrets.APPSTORE_KEY_ID }}.p8
          chmod 600 ~/.appstoreconnect/private_keys/AuthKey_${{ secrets.APPSTORE_KEY_ID }}.p8
          
          # Ensure our keychain is active and unlocked
          security default-keychain -s "$KEYCHAIN_NAME"
          security unlock-keychain -p "$KEYCHAIN_PASSWORD" "$KEYCHAIN_NAME"
          
          # Update project.pbxproj to set team ID for all targets
          echo "Setting development team ID..."
          sed -i '' "s/DevelopmentTeam = \"[^\"]*\"/DevelopmentTeam = \"${{ secrets.IOS_TEAM_ID }}\"/g" Unity-iPhone.xcodeproj/project.pbxproj
          sed -i '' "s/DevelopmentTeam = ;/DevelopmentTeam = \"${{ secrets.IOS_TEAM_ID }}\";/g" Unity-iPhone.xcodeproj/project.pbxproj
          sed -i '' "s/DEVELOPMENT_TEAM = \"[^\"]*\"/DEVELOPMENT_TEAM = \"${{ secrets.IOS_TEAM_ID }}\"/g" Unity-iPhone.xcodeproj/project.pbxproj
          sed -i '' "s/DEVELOPMENT_TEAM = ;/DEVELOPMENT_TEAM = \"${{ secrets.IOS_TEAM_ID }}\";/g" Unity-iPhone.xcodeproj/project.pbxproj
          
          # Configure code signing - use automatic signing for App Store distribution
          echo "Configuring code signing for App Store distribution..."
          # Use automatic signing which should handle In-App Purchase capability automatically
          sed -i '' 's/CODE_SIGN_STYLE = Manual/CODE_SIGN_STYLE = Automatic/g' Unity-iPhone.xcodeproj/project.pbxproj
          sed -i '' 's/CODE_SIGN_STYLE = ;/CODE_SIGN_STYLE = Automatic;/g' Unity-iPhone.xcodeproj/project.pbxproj
          
          # Remove ALL manual CODE_SIGN_IDENTITY settings - let automatic signing choose based on provisioning profile
          # With IOS_APP_STORE profiles, automatic signing will automatically use "Apple Distribution"
          sed -i '' '/CODE_SIGN_IDENTITY/d' Unity-iPhone.xcodeproj/project.pbxproj
          
          # Remove any PROVISIONING_PROFILE_SPECIFIER settings - let automatic signing choose the profile
          # Automatic signing will select the appropriate App Store profile automatically
          sed -i '' '/PROVISIONING_PROFILE_SPECIFIER/d' Unity-iPhone.xcodeproj/project.pbxproj
          
          # Ensure automatic signing works correctly
          # Xcode's automatic signing will select the App Store profile for the main app
          # Library targets (like GameAssembly) should be signed as part of the main app
          # or will use ad-hoc signing automatically if they don't need distribution profiles
          
          echo "Code signing configured: Automatic signing (Xcode will select profiles based on target type)"
          
          # Fix Unity framework issue: Set "Embedded Content Contains Swift Code" to NO
          # This prevents the "Invalid Bundle contains disallowed file 'Frameworks'" error
          # See: https://stackoverflow.com/questions/25880134/invalid-bundle-contains-disallowed-file-frameworks
          echo "Configuring Embedded Content Contains Swift Code to NO (Unity fix)..."
          # Set ALWAYS_EMBED_SWIFT_STANDARD_LIBRARIES to NO for all targets
          # This fixes the "Invalid Bundle contains disallowed file 'Frameworks'" error
          sed -i '' 's/ALWAYS_EMBED_SWIFT_STANDARD_LIBRARIES = YES/ALWAYS_EMBED_SWIFT_STANDARD_LIBRARIES = NO/g' Unity-iPhone.xcodeproj/project.pbxproj
          sed -i '' 's/ALWAYS_EMBED_SWIFT_STANDARD_LIBRARIES = "$(inherited)"/ALWAYS_EMBED_SWIFT_STANDARD_LIBRARIES = NO/g' Unity-iPhone.xcodeproj/project.pbxproj
          # Also set EMBEDDED_CONTENT_CONTAINS_SWIFT to NO if present
          sed -i '' 's/EMBEDDED_CONTENT_CONTAINS_SWIFT = YES/EMBEDDED_CONTENT_CONTAINS_SWIFT = NO/g' Unity-iPhone.xcodeproj/project.pbxproj
          echo "Embedded Content Contains Swift Code configured to NO"
          
          # Note: UnityFramework bundle identifier will be fixed post-archive
          # This is more reliable than trying to modify the Xcode project file
          # The post-archive fix step will update the Info.plist and remove signatures
          # so the export process can re-sign with the correct bundle ID
          echo "UnityFramework bundle ID will be fixed post-archive if needed"
          
          # Force device-only builds by excluding simulator architectures
          echo "Configuring for device-only build..."
          # Set ONLY_ACTIVE_ARCH to NO for Release builds
          sed -i '' 's/ONLY_ACTIVE_ARCH = YES/ONLY_ACTIVE_ARCH = NO/g' Unity-iPhone.xcodeproj/project.pbxproj
          
          echo "Build configuration updated for device-only build"
          
          # Get the provisioning profile UUID for manual signing
          # Prefer a profile with In-App Purchase capability
          PROFILE_PATH=""
          PROFILE_UUID=""
          
          # First, try to find a profile with In-App Purchase
          for profile in ~/Library/MobileDevice/Provisioning\ Profiles/*.mobileprovision; do
            if security cms -D -i "$profile" | grep -q "com.apple.InAppPurchase"; then
              PROFILE_PATH="$profile"
              PROFILE_UUID=$(basename "$profile" .mobileprovision)
              echo "âœ… Found profile with In-App Purchase: $PROFILE_UUID"
              break
            fi
          done
          
          # If no IAP profile found, use the first available profile
          if [ -z "$PROFILE_PATH" ]; then
          PROFILE_PATH=$(ls ~/Library/MobileDevice/Provisioning\ Profiles/*.mobileprovision | head -1)
          PROFILE_UUID=$(basename "$PROFILE_PATH" .mobileprovision)
            echo "âš ï¸  Using profile without In-App Purchase: $PROFILE_UUID"
            echo "âš ï¸  WARNING: This may cause build failures if the app requires In-App Purchase"
          fi
          
          echo "PROFILE_UUID=$PROFILE_UUID" >> $GITHUB_ENV
          echo "Using provisioning profile: $PROFILE_UUID from $PROFILE_PATH"
          
          # Extract the actual UUID from the profile (not just filename)
          ACTUAL_UUID=$(security cms -D -i "$PROFILE_PATH" | plutil -extract UUID raw - 2>/dev/null || echo "$PROFILE_UUID")
          echo "ACTUAL_PROFILE_UUID=$ACTUAL_UUID" >> $GITHUB_ENV
          echo "Actual profile UUID: $ACTUAL_UUID"
      
      # iOS: Verify build configuration
      - name: Verify build configuration
        if: inputs.platform == 'iOS'
        run: |
          cd build/iOS/iOS/
          
          echo "Available SDKs:"
          xcodebuild -showsdks | grep -i ios
          
          echo ""
          echo "Available destinations:"
          xcodebuild -project Unity-iPhone.xcodeproj -scheme Unity-iPhone -showdestinations | grep -i ios
          
          echo ""
          echo "Verifying we're building for device (iphoneos), not simulator..."
          SDK_VERSION=$(xcodebuild -version -sdk iphoneos Path 2>/dev/null | head -1)
          if [ -z "$SDK_VERSION" ]; then
            echo "ERROR: iphoneos SDK not found!"
            exit 1
          fi
          echo "âœ… Using device SDK: $SDK_VERSION"
      
      # iOS: Clean Xcode project
      - name: Clean Xcode project
        if: inputs.platform == 'iOS'
        run: |
          cd build/iOS/iOS/
          xcodebuild clean \
            -project Unity-iPhone.xcodeproj \
            -scheme Unity-iPhone \
            -configuration Release \
            -sdk iphoneos \
            -destination 'generic/platform=iOS'
      
      # iOS: Build archive for device
      - name: Build iOS archive
        if: inputs.platform == 'iOS'
        env:
          APP_STORE_CONNECT_API_KEY_ID: ${{ secrets.APPSTORE_KEY_ID }}
          APP_STORE_CONNECT_API_KEY_ISSUER_ID: ${{ secrets.APPSTORE_ISSUER_ID }}
          APP_STORE_CONNECT_API_KEY_KEY: ${{ secrets.APPSTORE_PRIVATE_KEY }}
          APP_STORE_CONNECT_API_KEY_IS_KEY_CONTENT_BASE64: false
        run: |
          cd build/iOS/iOS/
            
            # Ensure keychain is unlocked and in search path
            security unlock-keychain -p "$KEYCHAIN_PASSWORD" "$KEYCHAIN_NAME"
            security list-keychains -s "$KEYCHAIN_NAME" ~/Library/Keychains/login.keychain-db /Library/Keychains/System.keychain
            
          # Get version information from git
          echo "Getting version information from git..."
          cd ${{ github.workspace }}
          
          # Fetch all tags to ensure we have the latest
          git fetch --tags --force 2>/dev/null || echo "Note: Could not fetch tags (may not have remote access)"
          
          # Generate build number from timestamp (YYYYMMDDHHMM format)
          # Using UTC to avoid timezone issues
          BUILD_NUMBER=$(date -u +"%Y%m%d%H%M")
          echo "Build number (timestamp UTC): $BUILD_NUMBER"
          
          # Get latest tag (version)
          # Try to get the most recent tag, sorted by version
          LATEST_TAG=$(git tag --sort=-version:refname 2>/dev/null | head -1 || echo "")
          
          if [ -z "$LATEST_TAG" ]; then
            # Fallback: try git describe which might work even if tags aren't sorted
            LATEST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "")
          fi
          
          if [ -z "$LATEST_TAG" ]; then
            echo "âš ï¸  WARNING: No git tags found, using default version 1.0.0"
            LATEST_TAG="1.0.0"
          else
            # Remove 'v' prefix if present (e.g., "v1.0.0" -> "1.0.0")
            LATEST_TAG=$(echo "$LATEST_TAG" | sed 's/^v//')
            echo "Latest tag (version): $LATEST_TAG"
          fi
          
          # Return to iOS build directory
          cd build/iOS/iOS/
          
          echo "Setting iOS app version:"
          echo "  MARKETING_VERSION (version): $LATEST_TAG"
          echo "  CURRENT_PROJECT_VERSION (build): $BUILD_NUMBER"
          
          # Verify distribution certificates are available
          echo ""
          echo "Verifying available signing certificates:"
          security find-identity -v -p codesigning "$KEYCHAIN_NAME" | grep -i "distribution\|apple distribution" || {
            echo "âš ï¸  WARNING: No distribution certificate found in keychain"
            echo "Available certificates:"
            security find-identity -v -p codesigning "$KEYCHAIN_NAME"
          }
          
          # Verify App Store provisioning profiles are available and match our bundle ID
          echo ""
          echo "Verifying App Store provisioning profiles:"
          EXPECTED_BUNDLE_ID="com.stash.sdkdemo"
          APP_STORE_PROFILES_FOUND=0
          
          for profile in ~/Library/MobileDevice/Provisioning\ Profiles/*.mobileprovision; do
            PROFILE_DEVICES=$(security cms -D -i "$profile" 2>/dev/null | plutil -extract ProvisionedDevices raw - 2>/dev/null || echo "")
            PROFILE_BUNDLE_ID=$(security cms -D -i "$profile" 2>/dev/null | plutil -extract Entitlements.application-identifier raw - 2>/dev/null | sed 's/.*\.//' || echo "")
            PROFILE_NAME=$(security cms -D -i "$profile" 2>/dev/null | plutil -extract Name raw - 2>/dev/null || echo "")
            
            if [ -z "$PROFILE_DEVICES" ]; then
              # No ProvisionedDevices means it's an App Store profile
              if [ "$PROFILE_BUNDLE_ID" = "$EXPECTED_BUNDLE_ID" ]; then
                echo "âœ… Found matching App Store profile: $PROFILE_NAME ($(basename "$profile"))"
                APP_STORE_PROFILES_FOUND=$((APP_STORE_PROFILES_FOUND + 1))
              else
                echo "â„¹ï¸  Found App Store profile (different bundle ID): $PROFILE_NAME (bundle: $PROFILE_BUNDLE_ID)"
              fi
            fi
          done
          
          if [ "$APP_STORE_PROFILES_FOUND" -eq 0 ]; then
            echo "âš ï¸  WARNING: No App Store provisioning profile found for bundle ID: $EXPECTED_BUNDLE_ID"
            echo "Xcode may try to use development signing instead"
          fi
          
          # List all provisioning profiles for debugging
          echo ""
          echo "All provisioning profiles:"
          ls -la ~/Library/MobileDevice/Provisioning\ Profiles/ 2>/dev/null || echo "No profiles directory found"
            
          # Build archive for device (not simulator)
          # Use generic iOS device destination to avoid simulator
          # Note: With automatic signing, Xcode will automatically select the correct certificate
          # based on the provisioning profile. We download IOS_APP_STORE profiles which require
          # "Apple Distribution" certificates. Do NOT manually override CODE_SIGN_IDENTITY as it
          # conflicts with automatic signing.
          xcodebuild archive \
            -project Unity-iPhone.xcodeproj \
              -scheme Unity-iPhone \
              -configuration Release \
              -sdk iphoneos \
            -destination 'generic/platform=iOS' \
              -archivePath Unity-iPhone.xcarchive \
              -authenticationKeyPath ~/.appstoreconnect/private_keys/AuthKey_${{ secrets.APPSTORE_KEY_ID }}.p8 \
              -authenticationKeyID ${{ secrets.APPSTORE_KEY_ID }} \
              -authenticationKeyIssuerID ${{ secrets.APPSTORE_ISSUER_ID }} \
              DEVELOPMENT_TEAM="${{ secrets.IOS_TEAM_ID }}" \
              PRODUCT_BUNDLE_IDENTIFIER="com.stash.sdkdemo" \
              MARKETING_VERSION="$LATEST_TAG" \
              CURRENT_PROJECT_VERSION="$BUILD_NUMBER" \
              CODE_SIGN_STYLE="Automatic" \
              CODE_SIGNING_ALLOWED="YES" \
              CODE_SIGNING_REQUIRED="YES" \
            ALWAYS_EMBED_SWIFT_STANDARD_LIBRARIES=NO \
              OTHER_CODE_SIGN_FLAGS="--keychain $KEYCHAIN_NAME" \
            ONLY_ACTIVE_ARCH=NO \
            EXCLUDED_ARCHS[sdk=iphonesimulator*]="arm64"
          
          echo "Archive created successfully"
          ls -la Unity-iPhone.xcarchive/
          
          # Verify bundle identifiers are correct
          echo ""
          echo "Verifying bundle identifiers..."
          APP_BUNDLE=$(find Unity-iPhone.xcarchive -name "*.app" -type d | head -1)
          if [ -n "$APP_BUNDLE" ]; then
            # Check main app bundle identifier
            MAIN_BUNDLE_ID=$(plutil -extract CFBundleIdentifier raw "$APP_BUNDLE/Info.plist" 2>/dev/null || echo "")
            echo "Main app bundle ID: $MAIN_BUNDLE_ID"
            
            # Check UnityFramework bundle identifier
            UNITY_FRAMEWORK_PLIST="$APP_BUNDLE/Frameworks/UnityFramework.framework/Info.plist"
            if [ -f "$UNITY_FRAMEWORK_PLIST" ]; then
              UNITY_FRAMEWORK_BUNDLE_ID=$(plutil -extract CFBundleIdentifier raw "$UNITY_FRAMEWORK_PLIST" 2>/dev/null || echo "")
              if [ -n "$UNITY_FRAMEWORK_BUNDLE_ID" ]; then
                echo "UnityFramework bundle ID: $UNITY_FRAMEWORK_BUNDLE_ID"
                if [ "$UNITY_FRAMEWORK_BUNDLE_ID" = "$MAIN_BUNDLE_ID" ]; then
                  echo "âš ï¸  WARNING: UnityFramework has same bundle ID as main app!"
                elif [ "$UNITY_FRAMEWORK_BUNDLE_ID" = "${MAIN_BUNDLE_ID}.UnityFramework" ]; then
                  echo "âœ… UnityFramework has unique bundle ID"
                else
                  echo "â„¹ï¸  UnityFramework bundle ID is different: $UNITY_FRAMEWORK_BUNDLE_ID"
                fi
              else
                echo "âš ï¸  WARNING: UnityFramework has no bundle ID (this will cause validation errors)"
              fi
            fi
            
            # Check for nested Frameworks folder (the Unity issue)
            if [ -d "$APP_BUNDLE/Frameworks/UnityFramework.framework/Frameworks" ]; then
              echo "âš ï¸  WARNING: Found nested Frameworks folder in UnityFramework.framework"
              echo "   This should be fixed by ALWAYS_EMBED_SWIFT_STANDARD_LIBRARIES=NO"
            else
              echo "âœ… No nested Frameworks folder found"
            fi
          fi
          
          # Verify archive is built for device, not simulator
          echo ""
          echo "Verifying archive architecture..."
          ARCHIVE_BINARY=$(find Unity-iPhone.xcarchive -name "UnityFramework" -type f | head -1)
          if [ -n "$ARCHIVE_BINARY" ]; then
            echo "Checking binary architectures:"
            file "$ARCHIVE_BINARY"
            lipo -info "$ARCHIVE_BINARY" || echo "lipo info:"
            echo ""
            echo "Checking for simulator architectures (should be empty):"
            lipo -info "$ARCHIVE_BINARY" 2>&1 | grep -i simulator && echo "âš ï¸  WARNING: Simulator architectures found!" || echo "âœ… No simulator architectures found"
          fi
      
      # iOS: Fix UnityFramework bundle identifier in archive (post-archive fix)
      - name: Fix UnityFramework bundle identifier in archive
        if: inputs.platform == 'iOS'
        run: |
          cd build/iOS/iOS/
          
          echo "Fixing UnityFramework bundle identifier in archive..."
          
          # Find the app bundle in the archive
          APP_BUNDLE=$(find Unity-iPhone.xcarchive -name "*.app" -type d | head -1)
          if [ -z "$APP_BUNDLE" ]; then
            echo "ERROR: Could not find app bundle in archive"
                exit 1
              fi
          
          MAIN_BUNDLE_ID="com.stash.sdkdemo"
          UNITY_FRAMEWORK_BUNDLE_ID="${MAIN_BUNDLE_ID}.UnityFramework"
          UNITY_FRAMEWORK_PLIST="$APP_BUNDLE/Frameworks/UnityFramework.framework/Info.plist"
          
          if [ ! -f "$UNITY_FRAMEWORK_PLIST" ]; then
            echo "UnityFramework.framework/Info.plist not found, skipping fix"
            exit 0
          fi
          
          # Check current bundle ID
          CURRENT_BUNDLE_ID=$(plutil -extract CFBundleIdentifier raw "$UNITY_FRAMEWORK_PLIST" 2>/dev/null || echo "")
          echo "UnityFramework current bundle ID: $CURRENT_BUNDLE_ID"
          echo "Target bundle ID: $UNITY_FRAMEWORK_BUNDLE_ID"
          
          # Always update the bundle ID if it doesn't match, and re-sign
          if [ "$CURRENT_BUNDLE_ID" != "$UNITY_FRAMEWORK_BUNDLE_ID" ]; then
            echo "âš ï¸  UnityFramework has bundle ID: $CURRENT_BUNDLE_ID, updating to: $UNITY_FRAMEWORK_BUNDLE_ID"
            
            # Update the bundle ID in Info.plist
            plutil -replace CFBundleIdentifier -string "$UNITY_FRAMEWORK_BUNDLE_ID" "$UNITY_FRAMEWORK_PLIST"
            echo "âœ… Updated Info.plist bundle ID to: $UNITY_FRAMEWORK_BUNDLE_ID"
            
            # Get the codesign identity from the app's existing signature or keychain
            echo "Finding codesign identity..."
            CODESIGN_IDENTITY=$(codesign -dvv "$APP_BUNDLE" 2>&1 | grep "Authority" | head -1 | sed -E 's/.*Authority=([^ ]+).*/\1/' || echo "")
            
            # If not found, try to get from security find-identity
            if [ -z "$CODESIGN_IDENTITY" ]; then
              CODESIGN_IDENTITY=$(security find-identity -v -p codesigning | grep "Apple Distribution" | head -1 | sed -E 's/.*"([^"]+)".*/\1/' || echo "")
            fi
            
            # If still not found, try Apple Development
            if [ -z "$CODESIGN_IDENTITY" ]; then
              CODESIGN_IDENTITY=$(security find-identity -v -p codesigning | grep "Apple Development" | head -1 | sed -E 's/.*"([^"]+)".*/\1/' || echo "")
            fi
            
            if [ -z "$CODESIGN_IDENTITY" ]; then
              echo "âš ï¸  WARNING: Could not determine codesign identity"
              echo "Available identities:"
              security find-identity -v -p codesigning || true
              echo "Will attempt to use automatic signing identity..."
              CODESIGN_IDENTITY="Apple Distribution"
            else
              echo "Using codesign identity: $CODESIGN_IDENTITY"
            fi
            
            # Remove existing signature from framework
            echo "Removing existing signature from UnityFramework.framework..."
            codesign --remove-signature "$APP_BUNDLE/Frameworks/UnityFramework.framework" 2>/dev/null || {
              # If remove-signature doesn't work, just delete the _CodeSignature folder
              rm -rf "$APP_BUNDLE/Frameworks/UnityFramework.framework/_CodeSignature" 2>/dev/null || true
            }
            
            # Re-sign the framework with the new bundle ID
            echo "Re-signing UnityFramework.framework with bundle ID: $UNITY_FRAMEWORK_BUNDLE_ID..."
            codesign --force --sign "$CODESIGN_IDENTITY" \
              --identifier "$UNITY_FRAMEWORK_BUNDLE_ID" \
              --timestamp=none \
              "$APP_BUNDLE/Frameworks/UnityFramework.framework" || {
              echo "âš ï¸  First attempt failed, trying with - option (let system choose identity)..."
              codesign --force --sign "-" \
                --identifier "$UNITY_FRAMEWORK_BUNDLE_ID" \
                --timestamp=none \
                "$APP_BUNDLE/Frameworks/UnityFramework.framework" || {
                echo "âŒ ERROR: Failed to re-sign framework"
                exit 1
              }
            }
            
            # Verify the signature
            echo "Verifying framework signature..."
            codesign -vv "$APP_BUNDLE/Frameworks/UnityFramework.framework" 2>&1 || {
              echo "âš ï¸  WARNING: Framework signature verification failed"
            }
            
            # Check that the identifier in the signature matches
            SIGNATURE_ID=$(codesign -dvv "$APP_BUNDLE/Frameworks/UnityFramework.framework" 2>&1 | grep "Identifier" | head -1 | sed -E 's/.*Identifier=([^ ]+).*/\1/' || echo "")
            if [ "$SIGNATURE_ID" = "$UNITY_FRAMEWORK_BUNDLE_ID" ]; then
              echo "âœ… Verified: Framework signature identifier matches: $SIGNATURE_ID"
            else
              echo "âš ï¸  WARNING: Signature identifier is: $SIGNATURE_ID, expected: $UNITY_FRAMEWORK_BUNDLE_ID"
            fi
            
            # Verify the bundle ID in Info.plist
            VERIFY_BUNDLE_ID=$(plutil -extract CFBundleIdentifier raw "$UNITY_FRAMEWORK_PLIST" 2>/dev/null || echo "")
            if [ "$VERIFY_BUNDLE_ID" = "$UNITY_FRAMEWORK_BUNDLE_ID" ]; then
              echo "âœ… Verified: Info.plist bundle ID is: $VERIFY_BUNDLE_ID"
            else
              echo "âš ï¸  WARNING: Info.plist bundle ID is: $VERIFY_BUNDLE_ID, expected: $UNITY_FRAMEWORK_BUNDLE_ID"
            fi
          else
            echo "âœ… UnityFramework already has correct bundle ID: $UNITY_FRAMEWORK_BUNDLE_ID"
            
            # Verify the signature matches the bundle ID
            SIGNATURE_ID=$(codesign -dvv "$APP_BUNDLE/Frameworks/UnityFramework.framework" 2>&1 | grep "Identifier" | head -1 | sed -E 's/.*Identifier=([^ ]+).*/\1/' || echo "")
            if [ "$SIGNATURE_ID" != "$UNITY_FRAMEWORK_BUNDLE_ID" ]; then
              echo "âš ï¸  WARNING: Signature identifier ($SIGNATURE_ID) doesn't match bundle ID ($UNITY_FRAMEWORK_BUNDLE_ID)"
              echo "Re-signing framework to fix signature..."
              
              # Get codesign identity
              CODESIGN_IDENTITY=$(codesign -dvv "$APP_BUNDLE" 2>&1 | grep "Authority" | head -1 | sed -E 's/.*Authority=([^ ]+).*/\1/' || echo "Apple Distribution")
              
              # Remove and re-sign
              codesign --remove-signature "$APP_BUNDLE/Frameworks/UnityFramework.framework" 2>/dev/null || true
              codesign --force --sign "$CODESIGN_IDENTITY" \
                --identifier "$UNITY_FRAMEWORK_BUNDLE_ID" \
                --timestamp=none \
                "$APP_BUNDLE/Frameworks/UnityFramework.framework" || {
                codesign --force --sign "-" \
                  --identifier "$UNITY_FRAMEWORK_BUNDLE_ID" \
                  --timestamp=none \
                  "$APP_BUNDLE/Frameworks/UnityFramework.framework"
              }
              echo "âœ… Re-signed framework with correct identifier"
            fi
          fi
      
      # iOS: Create export options
      - name: Create export options plist
        if: inputs.platform == 'iOS'
        run: |
          cd build/iOS/iOS/
          
          cat > exportOptions.plist << EOF
          <?xml version="1.0" encoding="UTF-8"?>
          <!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
          <plist version="1.0">
          <dict>
              <key>method</key>
              <string>app-store</string>
              <key>teamID</key>
              <string>${{ secrets.IOS_TEAM_ID }}</string>
              <key>signingStyle</key>
              <string>automatic</string>
              <key>uploadBitcode</key>
              <false/>
              <key>uploadSymbols</key>
              <true/>
              <key>generateAppStoreInformation</key>
              <false/>
          </dict>
          </plist>
          EOF
          
          echo "Export options created:"
          cat exportOptions.plist
      
      # iOS: Export IPA
      - name: Export IPA
        if: inputs.platform == 'iOS'
        env:
          APP_STORE_CONNECT_API_KEY_ID: ${{ secrets.APPSTORE_KEY_ID }}
          APP_STORE_CONNECT_API_KEY_ISSUER_ID: ${{ secrets.APPSTORE_ISSUER_ID }}
          APP_STORE_CONNECT_API_KEY_KEY: ${{ secrets.APPSTORE_PRIVATE_KEY }}
          APP_STORE_CONNECT_API_KEY_IS_KEY_CONTENT_BASE64: false
        run: |
          cd build/iOS/iOS/
          
          # Ensure keychain is unlocked
          security unlock-keychain -p "$KEYCHAIN_PASSWORD" "$KEYCHAIN_NAME"
          
          # Export IPA
          xcodebuild -exportArchive \
            -archivePath Unity-iPhone.xcarchive \
            -exportOptionsPlist exportOptions.plist \
            -exportPath export \
            -allowProvisioningUpdates \
            -authenticationKeyPath ~/.appstoreconnect/private_keys/AuthKey_${{ secrets.APPSTORE_KEY_ID }}.p8 \
            -authenticationKeyID ${{ secrets.APPSTORE_KEY_ID }} \
            -authenticationKeyIssuerID ${{ secrets.APPSTORE_ISSUER_ID }}
      
          echo "IPA export completed"
          ls -la export/
      
      # iOS: Diagnose bundle identifier collisions
      - name: Diagnose bundle identifier collisions
        if: inputs.platform == 'iOS'
        run: |
          cd build/iOS/iOS/export/
          IPA_PATH="StashDemo.ipa"
          
          if [ ! -f "$IPA_PATH" ]; then
            echo "ERROR: IPA file not found!"
            exit 1
          fi
          
          echo "=========================================="
          echo "DIAGNOSING BUNDLE IDENTIFIER COLLISIONS"
          echo "=========================================="
          echo ""
          
          # Extract IPA to temporary directory
          TEMP_DIR=$(mktemp -d)
          echo "Extracting IPA to: $TEMP_DIR"
          unzip -q "$IPA_PATH" -d "$TEMP_DIR/extracted"
          
          # Find the app bundle
          APP_BUNDLE=$(find "$TEMP_DIR/extracted" -name "*.app" -type d | head -1)
          if [ -z "$APP_BUNDLE" ]; then
            echo "ERROR: Could not find app bundle in IPA"
            exit 1
          fi
          
          echo "App bundle found: $APP_BUNDLE"
          echo ""
          
          # Get main app bundle ID
          MAIN_BUNDLE_ID=$(plutil -extract CFBundleIdentifier raw "$APP_BUNDLE/Info.plist" 2>/dev/null || echo "")
          echo "ðŸ“± Main App Bundle ID: $MAIN_BUNDLE_ID"
          echo ""
          
          # Find all Info.plist files in the app bundle
          echo "Searching for all Info.plist files..."
          echo "----------------------------------------"
          COLLISIONS_FOUND=0
          
          find "$APP_BUNDLE" -name "Info.plist" -type f | while read plist; do
            RELATIVE_PATH="${plist#$APP_BUNDLE/}"
            BUNDLE_ID=$(plutil -extract CFBundleIdentifier raw "$plist" 2>/dev/null || echo "")
            
            if [ -n "$BUNDLE_ID" ]; then
              echo ""
              echo "ðŸ“ Location: $RELATIVE_PATH"
              echo "   Bundle ID: $BUNDLE_ID"
              
              if [ "$BUNDLE_ID" = "$MAIN_BUNDLE_ID" ]; then
                echo "   âš ï¸  COLLISION DETECTED - Same as main app!"
                COLLISIONS_FOUND=1
                
                # Show more details about this file
                echo "   Details:"
                plutil -p "$plist" | grep -E "(CFBundleName|CFBundleExecutable|CFBundlePackageType)" | head -3 | sed 's/^/      /'
              else
                echo "   âœ“ Unique bundle ID"
              fi
            else
              echo ""
              echo "ðŸ“ Location: $RELATIVE_PATH"
              echo "   (No CFBundleIdentifier found)"
            fi
          done
          
          echo ""
          echo "----------------------------------------"
          echo "Summary of bundle structure:"
          echo ""
          echo "Frameworks:"
          find "$APP_BUNDLE/Frameworks" -name "*.framework" -type d 2>/dev/null | while read fw; do
            echo "  - $(basename "$fw")"
          done
          
          echo ""
          echo "Extensions:"
          find "$APP_BUNDLE" -name "*.appex" -type d 2>/dev/null | while read ext; do
            echo "  - $(basename "$ext")"
          done
          
          echo ""
          echo "PlugIns:"
          find "$APP_BUNDLE/PlugIns" -name "*.appex" -type d 2>/dev/null | while read plugin; do
            echo "  - $(basename "$plugin")"
          done
          
          echo ""
          echo "=========================================="
          echo "Diagnostic complete. Check output above for collisions."
          echo "=========================================="
          
          # Cleanup
          rm -rf "$TEMP_DIR"
      
      # iOS: Verify IPA
      - name: Verify IPA
        if: inputs.platform == 'iOS'
        run: |
          echo "Contents of build/iOS/iOS/export:"
          ls -la build/iOS/iOS/export/
          echo ""
          echo "Looking for IPA files:"
          find build/iOS/iOS -name "*.ipa" -type f
      
          # Verify IPA exists
          if [ ! -f "build/iOS/iOS/export/StashDemo.ipa" ]; then
            echo "ERROR: IPA file not found!"
            exit 1
          fi
          
          echo "âœ… IPA file found: build/iOS/iOS/export/StashDemo.ipa"
          du -h build/iOS/iOS/export/StashDemo.ipa
      
      # iOS: Upload to TestFlight using Apple's recommended action
      - name: Upload to TestFlight
        if: inputs.platform == 'iOS'
        uses: apple-actions/upload-testflight-build@v1
        with:
          app-path: 'build/iOS/iOS/export/StashDemo.ipa'
          issuer-id: ${{ secrets.APPSTORE_ISSUER_ID }}
          api-key-id: ${{ secrets.APPSTORE_KEY_ID }}
          api-private-key: ${{ secrets.APPSTORE_PRIVATE_KEY }}
      
      # Upload build artifacts
      - name: Upload build artifacts
        uses: actions/upload-artifact@v4
        with:
          name: Build-${{ inputs.platform }}
          path: build/${{ inputs.platform }}
          retention-days: 7